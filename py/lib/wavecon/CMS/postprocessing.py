"""
Overview
--------

This module provides an interface to data stored in the XMDF output files
generated by CMS-Wave and CMS-Flow.  The XMDF data format is built upon HDF5 and
is readable using HDF tools.

**Development Status:**
  **Last Modified:** December 16, 2010 by Charlie Sharpsteen

"""


#------------------------------------------------------------------------------
#  Imports from Python 2.7 standard library
#------------------------------------------------------------------------------
from datetime import datetime, timedelta
from os import path
from glob import glob

from math import sqrt, atan2


#------------------------------------------------------------------------------
#  Imports from third party libraries
#------------------------------------------------------------------------------
from numpy import array
import h5py


#------------------------------------------------------------------------------
#  Imports from other CMS submodules
#------------------------------------------------------------------------------
from .cmcards import cmcards_parser
from .gridfiles import telfile_parser, depfile_parser, georeference_grid
from wavecon.util import compass_degrees


#------------------------------------------------------------------------------
#  Data Retrieval
#------------------------------------------------------------------------------
def postprocess_CMS_run(cmcardsPath):
  run_meta = load_run_metadata(cmcardsPath)

  tel_grid = georeference_grid(
    telfile_parser(run_meta['grid_info']['telgrid_file']),
    run_meta['grid_info']
  )

  dep_grid = georeference_grid(
    depfile_parser(run_meta['grid_info']['depgrid_file']),
    run_meta['grid_info']
  )

  return {
    'run_info': run_meta['run_info'],
    'current_records': load_current_data(dep_grid, run_meta['current_data']),
    'wave_records': load_wave_data(dep_grid, run_meta['wave_data'])
  }


def load_run_metadata(cmcardsPath):
  cmcards = cmcards_parser.parseFile(cmcardsPath)

  sim_dir = path.dirname(cmcardsPath)
  cmcards_file = path.splitext(path.basename(cmcardsPath))[0]
  # Brute force search for the wave sim file---probably a more elegant way to do
  # this.
  sim_file = glob(path.join(sim_dir,'*.sim'))
  if len(sim_file) != 0:
    sim_file = sim_file[0]
  else:
    raise IOError('''Could not find a CMS-wave *.sim file.  The directory:
        {0}
    Was searched for files ending in .sim'''.format(sim_dir))

  start_time = datetime.strptime(
    '{0} {1}'.format(
      cmcards.STARTING_JDATE[0],
      cmcards.STARTING_JDATE_HOUR[0]
    ), '%y%j %H' )

  stop_time = start_time + timedelta(hours = cmcards.DURATION_RUN[0])

  sim_label = cmcards.SIMULATION_LABEL[0]

  run_info = {
    'run_name':  '{0}-{1}'.format(cmcards_file, sim_label),
    'start_time': start_time,
    'stop_time': stop_time,
  }

  grid_info = {
    'grid_origin': (cmcards.GRID_ORIGIN_X[0], cmcards.GRID_ORIGIN_Y[0]),
    'grid_angle': cmcards.GRID_ANGLE[0],
    'telgrid_file': path.join(sim_dir, cmcards_file) + '.tel',
    'depgrid_file': path.join(sim_dir, path.splitext(sim_file)[0]) + '.dep'
  }

  if cmcards.GRID_EPSG_CODE:
    grid_info['grid_epsg_code'] = 'EPSG:{0}'.format(cmcards.GRID_EPSG_CODE[0])
  else:
    raise LookupError('''
    In order to properly georeference CMS output, this program needs to know the
    spatial reference system (SRS) in which the following grid origin is
    expressed:

        {0}

    This is done by adding a non-standard card, GRID_EPSG_CODE, to:

        {1}

    This card contains an integer specifying the EPSG code of the SRS.  EPSG
    codes can be looked up at:

        www.spatialreference.org
    '''.format(
      grid_info['grid_origin'], cmcardsPath)
    )

  current_data = {
    'data_file': path.splitext(sim_file)[0] + '_out.h5',
    'current_vector': '/Dataset/Currents/Values',
    'output_timesteps': getDataOutputTimes(path.splitext(sim_file)[0] +\
      '_out.h5', '/Dataset/Currents', start_time)
  }

  wave_data = {
    'data_file': path.splitext(sim_file)[0] + '_out.h5',
    'wave_height': '/Dataset/Height/Values',
    'wave_period': '/Dataset/Period/Values',
    'wave_direction': '/Dataset/Direction/Values',
    'output_timesteps': getDataOutputTimes(path.splitext(sim_file)[0] +\
      '_out.h5', '/Dataset/Currents', start_time)
  }

  return {
    'run_info': run_info,
    'grid_info': grid_info,
    'current_data': current_data,
    'wave_data': wave_data
  }


def load_current_data(grid, current_info):
  data_file = h5py.File(current_info['data_file'], 'r')
  data_set = data_file[current_info['current_vector']].value
  data_file.close()

  # Because these datasets have a tendency to be HUGE, we return a generator
  # that is capable of producing the whole set rather than the set it's self.
  # The payoff is that the object is never explicitly created in memory (unless
  # expanded using list()).  The downside is that you can only iterate over the
  # generator once---after that it is "exhausted".
  for i in xrange(data_set.shape[0]):
    for j in xrange(data_set.shape[1]):
      yield {
        'speed': sqrt(data_set[i,j,0]**2 + data_set[i,j,1]**2),
        'direction': compass_degrees(atan2(data_set[i,j,0], data_set[i,j,1])),
        'timestamp': current_info['output_timesteps'][i],
        'location': grid[j]
      }


def load_wave_data(grid, wave_info):
  data_file = h5py.File(wave_info['data_file'], 'r')
  height_data = data_file[wave_info['wave_height']].value
  period_data = data_file[wave_info['wave_period']].value
  direction_data = data_file[wave_info['wave_direction']].value
  data_file.close()

  # See notes for load_current_data
  for i in xrange(height_data.shape[0]):
    for j in xrange(height_data.shape[1]):
      # Find a way to avoid recasting numpy values.
      yield {
        'height': float(height_data[i,j]),
        'period': float(period_data[i,j]),
        'direction': float(direction_data[i,j]),
        'timestamp': wave_info['output_timesteps'][i], 
        'location': grid[j]
      }

#---------------------------------------------------------------------
#  Utility Functions
#---------------------------------------------------------------------
def getDataOutputTimes(data_file, dataset_path, start_time):
  data_file = h5py.File(data_file, 'r')
  timesteps = data_file[dataset_path + '/Times'].value
  data_file.close()

  output_timesteps = [
    start_time + timedelta(hours = x)
    for x in timesteps
  ]

  return output_timesteps

